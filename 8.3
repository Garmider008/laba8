import numpy as np#підключаємо нампай
n,m=int(input('Кількість рядків в першій матриці')), int(input('Кількість стовпців в першій матриці'))#задаємо розмірність у першій матриці
k,b=int(input('Кількість рядків в другій матриці')), int(input('Кількість стовпців в другій матриці '))#задаємо розмірність у другій матриці
a=np.zeros((n,m), dtype=int)#створюємо матрицю з першою розмірністю заповнену нулями
o=np.zeros((n,b), dtype=int)# результуюча матриця при множенні буде мати розморність [n,b], тому стоврюємо таку матрицю і заповнюємо нулями
z=np.zeros((k,b), dtype=int)# аналогічно створюємо матрицю з другою розмірністю заповнену нулями
for i in range(n):
    for j in range(m):
        a[i,j]=int(input(f'A[{i},{j}]='))# проходимось по рядкам і стовпцям і запомнюємо нашу матрицю числами(перша матриця)
print(a)
for i in range(k):
    for j in range(b):
        z[i,j]=int(input(f'z[{j},{j}]='))# проходимось по рядкам і стовпцям і запомнюємо нашу матрицю числами (друга матриця)
print(b)
if m==k:#перевіряємо чи в нас рівна розмірність
    for i in range(n):#проходимось по стовпям і рядкам двох матриць і в нову комірку пам'яті в новій матриці записуємо результат при множені рядка на стопчик
        for j in range(m):
            for x in range(k):
                for j in range(b):
                    o[i][j] = a[0][i] * z[j][0] + a[1][i] * z[j][1] + a[2][i] * z[j][2]

    o=o.transpose()
    print(o)# виводимо результат
elif m!=k:#якщо розмірність не вірна, виходимо з програми
    exit()
